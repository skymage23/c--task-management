Have some way to map task_id to a task name.

When someone tries to send a letter using a task name, the mailing system sends a UtilityLetter back to 
the task controller asking it for the ID mapped to that name.  The task controller sends the task
runner a reply either with the task ID asked for or, if the ID is non-existent, nothing.

When waiting for return values, will Futures be enough, or do we need some kind of more
generic BroadcastReceiver like Android?


Concept of communication types;
Types:
1. API
2. One-way Pipeline
3. Broadcast (we can handle this within the mailbox using broadcast IDs generated by the mailbox).
   A broadcast ID identifies a group of recipients to which to send new letters being broadcasted with said ID.
   Tasks can use a method TaskRunnerHandle to request new broadcasts and another method to add receivers to 
   said broadcast.
   
4. Double-ended queue.
5. 



Consider having some way to evolve the main UI thread into some sortof root TaskRunner that starts by running a basic task.
--In that case, we need some way to 


Tasks need some kind of contextual storage system to preserver variable values between iterations.

template <typename T> Task::envelop_into_letter(T input);

//This is where not being Java leaves me with a fucking mess.
class TaskReturnValue {
    bool success;
    unordered_map
    //Need to implement via binary blobd.
};


What if we make the TaskController a Task in and of itself, running on a special task runner.  This would
greatly simplify how the task controller handles message routing and task creation, making time for both duties
thanks to task scheduling.

In that case, we need a special type of mailbox, the client-side mailbox, that allows unwrapped code to communicate with
code wrapped in Task objects.






